use std::ffi::OsStr;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

/// gRPC proto builder
#[derive(Default, Debug)]
pub struct GRPCBuilder {
    // your protobuf dir,default: ./proto
    proto_dir: PathBuf,

    // grpc out dir,default: src/polaris_rust
    out_dir: Option<PathBuf>,

    // proto filename
    proto_list: Vec<PathBuf>,
}

/// GRPCBuilder grpc builder
impl GRPCBuilder {
    pub fn new() -> Self {
        Self {
            proto_dir: "./proto".into(),
            out_dir: Some("src/polaris_rust".into()),
            proto_list: Vec::new(),
        }
    }

    pub fn with_out_dir<P: AsRef<Path>>(mut self, out_dir: P) -> Self {
        self.out_dir = Some(out_dir.as_ref().to_path_buf());
        self
    }

    pub fn with_proto_dir<P: AsRef<Path>>(mut self, proto_dir: P) -> Self {
        self.proto_dir = proto_dir.as_ref().to_path_buf();
        self
    }

    pub fn with_proto_list<P: AsRef<Path>>(mut self, proto_list: Vec<P>) -> Self {
        let mut list = vec![];
        for value in proto_list {
            list.push(value.as_ref().to_path_buf());
        }

        self.proto_list = list;
        self
    }

    pub fn generate(self) -> Result<(), Box<dyn std::error::Error>> {
        println!("generate grpc code start...");
        let mut file_list = Vec::new();
        if self.proto_list.is_empty() {
            // read proto file from includes
            let lists = self
                .proto_dir
                .as_path()
                .read_dir()
                .expect("read proto dir failed");
            for entry_path in lists {
                if entry_path.as_ref().unwrap().path().is_file() {
                    file_list.push(entry_path.unwrap().path())
                }
            }
        } else {
            file_list = self.proto_list
        }

        let out_dir = self.out_dir.unwrap();
        let _ = fs::create_dir(out_dir.as_path()); // create out dir

        // gen rust grpc code
        tonic_build::configure()
            .out_dir(out_dir.as_path())
            .compile(&file_list, &[self.proto_dir.as_path()])?;

        let ext: Option<&OsStr> = Some(&OsStr::new("proto"));
        let mut mod_file = fs::OpenOptions::new()
            .write(true)
            .create(true)
            .open(Path::new(&out_dir).join("mod.rs"))
            .expect("create mod.rs failed");
        let header = String::from("// Code generated by polaris-grpc-build.DO NOT EDIT!!!\n");
        let _ = mod_file.write(header.as_bytes());
        for file in &file_list.iter().next() {
            if file.extension().eq(&ext) {
                if let Some(file) = file.file_name() {
                    let f = file.to_str().unwrap();
                    let filename = f.replace(".proto", "");
                    println!("current proto: {}", f);
                    let _ = mod_file.write(format!("pub mod {};\n", filename).as_bytes());
                }
            }
        }

        println!("generate grpc code success!");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn gen_code() {
        // let _ = GRPCBuilder::new().generate();
        let _ = GRPCBuilder::new()
            .with_proto_dir("./examples/proto")
            .with_out_dir("./examples/src/rust_grpc")
            .generate();
    }
}
